'use strict';

const os = require('os');
const Logs = require('./logs');
const ExpressApp = require('./server');
const Alerts = require('./server/utils/alerts');

const Main = {
  appName: null,
  environmentName: process.env.NODE_ENV || null,
  serverName: null,
  pendingAlerts: [],
  isInitializated: false,

  initialize (options) {
    this.isInitializated = true;
    this.loadPackageInfo();
    this.setupConfiguration(options);
    Logs.initialize(options);
    this.startServer(options);
    this.handleUncaughtExceptions(options);
    this.handleSignalEvents();
    this.flushAlerts();
  },

  loadPackageInfo () {
    try {
      this.serverName = os.hostname() || null;
      const packageJSON = require('../../../../package.json');
      this.appName = packageJSON.name || null;
    } catch (err) {
    }
  },

  setupConfiguration (options) {
    this.appName = options.appName || this.appName;
    this.environmentName = options.environmentName || this.environmentName;
    this.serverName = options.serverName || this.serverName;
    options.port = parseInt(options.port, 10) || 8001;
    options.enableDashboard = typeof options.enableDashboard === 'boolean' ? options.enableDashboard : true;
    options.exitOnException = typeof options.exitOnException === 'boolean' ? options.exitOnException : true;
  },

  startServer (options) {
    if (options.enableDashboard) {
      ExpressApp.addStorage(options);
      ExpressApp.addPath(options);
      ExpressApp.listen(options.port, () => {
        const basePath = options.path || '';
        console.log(`Errsole Dashboard is accessible at http://localhost:${options.port}${basePath}`);
      });
    } else {
      console.log('Errsole Dashboard is disabled: You have disabled the Errsole Dashboard in the Errsole module configuration.');
    }
  },

  generateUniqueId () {
    const timestamp = Date.now();
    const randomNumber = Math.floor(Math.random() * 100000);
    return parseInt(`${timestamp}${randomNumber}`);
  },

  async customLogger (level, message, metadata) {
    if (level === 'alert') {
      const errsoleLogId = this.generateUniqueId();
      const messageExtraInfo = {
        appName: this.appName,
        environmentName: this.environmentName,
        serverName: this.serverName
      };
      const timestamp = new Date().toISOString();
      Logs.logCustomMessage(level, message, metadata, errsoleLogId, timestamp);
      if (this.isInitializated) {
        await Alerts.customLoggerAlert(message, messageExtraInfo, errsoleLogId, timestamp);
      } else {
        this.pendingAlerts.push({ message, messageExtraInfo, errsoleLogId, timestamp });
      }
    } else {
      Logs.logCustomMessage(level, message, metadata);
    }
  },

  async handleUncaughtExceptions (options) {
    const exitOnException = options.exitOnException;
    process.on('uncaughtException', async (err, origin) => {
      const errorOrigin = `Origin: ${origin}`;
      const errorMessage = err.stack || err.message;
      console.error(`${errorOrigin}\n${errorMessage}`);
      const messageExtraInfo = {
        appName: this.appName,
        environmentName: this.environmentName,
        serverName: this.serverName
      };
      if (this.isInitializated) {
        const timestamp = new Date().toISOString();
        const errsoleLogId = this.generateUniqueId();
        Logs.logCustomMessage('alert', `${errorOrigin}\n${errorMessage}`, '{}', errsoleLogId, timestamp);
        await Logs.flushLogs();
        try {
          await Promise.race([
            Alerts.handleUncaughtExceptions(`${errorOrigin}\n${errorMessage}`, messageExtraInfo, errsoleLogId, timestamp),
            new Promise((resolve, reject) => setTimeout(() => reject(new Error('Sending notification timed out')), 5000))
          ]);
        } catch (err) { console.error(err); }
      }
      if (exitOnException) process.exit(1);
    });
  },

  async handleSignalEvents () {
    const self = this;
    const signalEvents = [
      { key: 'SIGINT', value: 'This signal is typically sent when a user presses Ctrl+C in the terminal where a program is running. It is a way to interrupt a running process.' },
      { key: 'SIGTERM', value: 'This signal requests a process to terminate. It allows the process to clean up resources and terminate gracefully.' },
      { key: 'SIGQUIT', value: 'This signal is sent when a user types Ctrl+\\ in the terminal. It instructs a process to quit and, in many cases, generate a core dump.' },
      { key: 'SIGABRT', value: 'This signal is generated by the process itself, usually when it detects a serious error and wants to abort.' }
    ];

    signalEvents.forEach(async (signalEvent) => {
      process.on(signalEvent.key, async () => {
        if (self.isInitializated) {
          console.log(`Gracefully closing on ${signalEvent.key} â€“ Flushing logs before exit...`);
          const messageExtraInfo = {
            appName: self.appName,
            environmentName: self.environmentName,
            serverName: self.serverName
          };
          const errsoleLogId = self.generateUniqueId();
          const timestamp = new Date().toISOString();
          Logs.logCustomMessage('alert', `The app has stopped with the signal ${signalEvent.key} - ${signalEvent.value}`, '{}', errsoleLogId, timestamp);
          await Logs.flushLogs();
          try {
            await Promise.race([
              Alerts.customLoggerAlert(`The app has stopped with the signal ${signalEvent.key} - ${signalEvent.value}`, messageExtraInfo, errsoleLogId, timestamp),
              new Promise((resolve, reject) => setTimeout(() => reject(new Error('Sending notification timed out')), 5000))
            ]);
          } catch (err) { console.error(err); }
        }
        process.exit(0);
      });
    });
  },

  async flushAlerts () {
    const alertsToFlush = [...this.pendingAlerts];
    this.pendingAlerts = [];

    try {
      for (let i = 0; i < alertsToFlush.length; i++) {
        const { message, messageExtraInfo, errsoleLogId, timestamp } = alertsToFlush[i];
        await Alerts.customLoggerAlert(message, messageExtraInfo, errsoleLogId, timestamp);
      }
    } catch (err) {
      console.error('Failed to flush alerts:', err);
    }
  }

};

module.exports = Main;
